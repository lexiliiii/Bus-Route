Index: src/main/java/edu/virginia/sde/hw5/DatabaseDriver.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.virginia.sde.hw5;\n\nimport javax.print.DocFlavor;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\nimport java.sql.*;\n\npublic class DatabaseDriver {\n    private final String sqliteFilename;\n    private Connection connection;\n    //TODO: DO NOT CALL COMMIT IN ANY METHODS\n    public DatabaseDriver(Configuration configuration) {\n        this.sqliteFilename = configuration.getDatabaseFilename();\n    }\n\n    public DatabaseDriver (String sqlListDatabaseFilename) {\n        this.sqliteFilename = sqlListDatabaseFilename;\n    }\n\n    /**\n     * Connect to a SQLite Database. This turns out Foreign Key enforcement, and disables auto-commits\n     * @throws SQLException\n     */\n    public void connect() throws SQLException {\n        if (connection != null && !connection.isClosed()) {\n            throw new IllegalStateException(\"The connection is already opened\");\n        }\n        connection = DriverManager.getConnection(\"jdbc:sqlite:\" + sqliteFilename);\n        //the next line enables foreign key enforcement - do not delete/comment out\n        connection.createStatement().execute(\"PRAGMA foreign_keys = ON\");\n        //the next line disables auto-commit - do not delete/comment out\n        connection.setAutoCommit(false);\n    }\n\n    /**\n     * Commit all changes since the connection was opened OR since the last commit/rollback\n     */\n    public void commit() throws SQLException {\n        connection.commit();\n    }\n\n    /**\n     * Rollback to the last commit, or when the connection was opened\n     */\n    public void rollback() throws SQLException {\n        connection.rollback();\n    }\n\n    /**\n     * Ends the connection to the database\n     */\n    public void disconnect() throws SQLException {\n        connection.close();\n    }\n\n    /**\n     * Creates the three database tables Stops, BusLines, and Routes, with the appropriate constraints including\n     * foreign keys, if they do not exist already. If they already exist, this method does nothing.\n     * As a hint, you'll need to create Routes last, and Routes must include Foreign Keys to Stops and\n     * BusLines.\n     * @throws SQLException\n     */\n    public void createTables() throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        String Stops =\n                \"CREATE TABLE IF NOT EXISTS Stops (\" +\n                        \"ID INTEGER NOT NULL PRIMARY KEY, \" +\n                        \"StopName TEXT NOT NULL, \" +\n                        \"Latitude REAL NOT NULL, \" +\n                        \"Longitude REAL NOT NULL);\";\n\n        String BusLines =\n                \"CREATE TABLE IF NOT EXISTS BusLines (\" +\n                        \"ID INTEGER NOT NULL PRIMARY KEY, \" +\n                        \"IsActive BOOLEAN NOT NULL, \" +\n                        \"LongName TEXT NOT NULL, \" +\n                        \"ShortName TEXT NOT NULL);\";\n\n        String Routes =\n                \"CREATE TABLE IF NOT EXISTS Routes (\" +\n                        \"ID INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, \" +\n                        \"BusLineID INTEGER NOT NULL, \" +\n                        \"StopID INTEGER NOT NULL, \" +\n                        \"RouteOrder INTEGER NOT NULL, \" +\n                        \"FOREIGN KEY (BusLineID) REFERENCES BusLines(ID) ON DELETE CASCADE, \" +\n                        \"FOREIGN KEY (StopID) REFERENCES Stops(ID) ON DELETE CASCADE);\";\n\n        // Using try-with-resources to ensure the statement is closed after execution\n        try (Statement statement = connection.createStatement()) {\n            statement.execute(Stops);\n            statement.execute(BusLines);\n            statement.execute(Routes);\n        } catch (SQLException e) {\n            throw new SQLException(\"Error creating tables: \" + e.getMessage());\n        }\n    }\n\n\n    /**\n     * Add a list of Stops to the Database. After adding all the stops, the changes will be committed. However,\n     * if any SQLExceptions occur, this method will rollback and throw the exception.\n     * @param stops - the stops to be added to the database\n     */\n    public void addStops(List<Stop> stops) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        String insertStops = \"INSERT INTO Stops (ID, StopName, Latitude, Longitude) VALUES (?, ?, ?, ?);\";\n\n        try (PreparedStatement pstmt = connection.prepareStatement(insertStops)) {\n            for (Stop stop : stops) {\n                pstmt.setInt(1, stop.getId());\n                pstmt.setString(2, stop.getName());\n                pstmt.setDouble(3, stop.getLatitude());\n                pstmt.setDouble(4, stop.getLongitude());\n                pstmt.executeUpdate();\n            }\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(\"Error adding stops: \" + e.getMessage());\n        }\n\n        //TODO: implement\n//        try {\n//            //Your JDBC code codes here\n//        } catch (SQLException e) {\n//            rollback(); //rolls back any changes before the Exception was thrown\n//            throw e; //still throws the SQLException\n//        }\n\n    }\n\n    /**\n     * Gets a list of all Stops in the database\n     */\n    public List<Stop> getAllStops() throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n        //TODO: implement\n\n        List<Stop> collection = new ArrayList<>();\n        String sql = \"SELECT * FROM Stops;\";\n\n        try (Statement statement = connection.createStatement();\n             ResultSet rs = statement.executeQuery(sql)) {\n\n            while (rs.next()) {\n                int id = rs.getInt(\"ID\");\n                String stopName = rs.getString(\"StopName\");\n                double latitude = rs.getDouble(\"Latitude\");\n                double longitude = rs.getDouble(\"Longitude\");\n\n                collection.add(new Stop(id, stopName, latitude, longitude));\n            }\n\n        } catch (SQLException e) {\n            throw new SQLException(\"Error reading from Stops table: \" + e.getMessage());\n        }\n        return collection;\n    }\n\n    /**\n     * Get a Stop by its ID number. Returns Optional.isEmpty() if no Stop matches the ID.\n     */\n    public Optional<Stop> getStopById(int stopId) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        String sql = \"SELECT * FROM Stops WHERE ID = ?\";\n\n        try (PreparedStatement statement = connection.prepareStatement(sql)) {\n            statement.setInt(1, stopId);\n            try (ResultSet rs = statement.executeQuery()) {\n                if (rs != null) {\n                    String stopName = rs.getString(\"StopName\");\n                    double latitude = rs.getDouble(\"Latitude\");\n                    double longitude = rs.getDouble(\"Longitude\");\n\n                    Stop stop = new Stop(stopId, stopName, latitude, longitude);\n                    return Optional.of(stop);\n                } else {\n                    return Optional.empty();\n                }\n            }\n        } catch (SQLException e) {\n            throw new SQLException(\"Error reading from Stops table: \" + e.getMessage());\n        }\n\n        //TODO: implement\n        //use select Query with a Where clause\n//        return Optional.empty();\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Get all Stops whose name contains the substring (case-insensitive). For example, the parameter \"Rice\"\n     * would return a List of Stops containing \"Whitehead Rd @ Rice Hall\"\n     */\n    public List<Stop> getStopsByName(String subString) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        List<Stop> collection = new ArrayList<>();\n        String sql = \"SELECT * FROM Stops;\";\n\n        try (Statement statement = connection.createStatement();\n             ResultSet rs = statement.executeQuery(sql)) {\n\n            while (rs.next()) {\n                String stopName = rs.getString(\"StopName\");\n                if(stopName.toLowerCase().contains(subString.toLowerCase())){\n                    int id = rs.getInt(\"ID\");\n                    double latitude = rs.getDouble(\"Latitude\");\n                    double longitude = rs.getDouble(\"Longitude\");\n                    collection.add(new Stop(id, stopName, latitude, longitude));\n                }\n            }\n\n        } catch (SQLException e) {\n            throw new SQLException(\"Error reading from Stops table: \" + e.getMessage());\n        }\n\n        //TODO: implement\n\n//SELECT * FROM COURSES WHERE Subject = ‘CS’;\n\n        return collection;\n    }\n\n    /**\n     * Add BusLines and their Routes to the database, including their routes. This method should only be called after\n     * Stops are added to the database via addStops, since Routes depends on the StopIds already being\n     * in the database. If any SQLExceptions occur, this method will rollback all changes since\n     * the method was called. This could happen if, for example, a BusLine contains a Stop that is not in the database.\n     */\n\n    public void addBusLines(List<BusLine> busLines) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        String insertBusLine = \"INSERT INTO BusLines (ID, IsActive, LongName, ShortName) VALUES (?, ?, ?, ?);\";\n\n        String insertRoute = \"INSERT INTO Routes (BusLineID, StopID, RouteOrder) VALUES (?, ?, ?);\";\n\n        try (PreparedStatement pstmtBusLine = connection.prepareStatement(insertBusLine, Statement.RETURN_GENERATED_KEYS);\n             PreparedStatement pstmtRoute = connection.prepareStatement(insertRoute)) {\n\n            for (BusLine busLine : busLines) {\n                pstmtBusLine.setInt(1, busLine.getId());\n                pstmtBusLine.setBoolean(2, busLine.isActive());\n                pstmtBusLine.setString(3, busLine.getLongName());\n                pstmtBusLine.setString(4, busLine.getShortName());\n                pstmtBusLine.executeUpdate();\n\n                Route routes = busLine.getRoute();\n                for (int i = 0; i < routes.size(); i++) {\n                    Stop route = routes.get(i);\n                    pstmtRoute.setInt(1, busLine.getId());\n                    pstmtRoute.setInt(2, route.getId());\n                    pstmtRoute.setInt(3, i);\n                    pstmtRoute.executeUpdate();\n                }\n            }\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        }\n    }\n\n\n    /**\n     * Return a list of all BusLines\n     */\n    public List<BusLine> getBusLines() throws SQLException{\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        List<BusLine> collection = new ArrayList<>();\n        String sql = \"SELECT * FROM Buslines;\";\n\n        try (Statement statement = connection.createStatement();\n             ResultSet rs = statement.executeQuery(sql)) {\n\n            while (rs.next()) {\n                int id = rs.getInt(\"ID\");\n                boolean isActive = rs.getBoolean(\"IsActive\");\n                String longName = rs.getString(\"LongName\");\n                String shortName = rs.getString(\"ShortName\");\n\n                collection.add(new BusLine(id, isActive, longName, shortName));\n            }\n\n        } catch (SQLException e) {\n            throw new SQLException(\"Error reading from Stops table: \" + e.getMessage());\n        }\n        return collection;\n\n        //TODO: implement\n    }\n\n    /**\n     * Get a BusLine by its id number. Return Optional.empty() if no busLine is found\n     */\n    public Optional<BusLine> getBusLinesById(int busLineId) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        String sql = \"SELECT * FROM BusLine WHERE ID = ?\";\n\n        try (PreparedStatement statement = connection.prepareStatement(sql)) {\n            statement.setInt(1, busLineId);\n            try (ResultSet rs = statement.executeQuery()) {\n                if (rs != null) {\n                    boolean isActive = rs.getBoolean(\"IsActive\");\n                    String longName = rs.getString(\"LongName\");\n                    String shortName = rs.getString(\"ShortName\");\n\n                    BusLine busLine = new BusLine(busLineId, isActive, longName, shortName);\n                    return Optional.of(busLine);\n                } else {\n                    return Optional.empty();\n                }\n            }\n        } catch (SQLException e) {\n            throw new SQLException(\"Error reading from Stops table: \" + e.getMessage());\n        }\n        //TODO: implement\n//        return Optional.empty();\n    }\n\n    /**\n     * Get BusLine by its full long name (case-insensitive). Return Optional.empty() if no busLine is found.\n     */\n    public Optional<BusLine> getBusLineByLongName(String longName) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        String sql = \"SELECT * FROM BusLine WHERE LongName = ?\";\n\n        try (PreparedStatement statement = connection.prepareStatement(sql)) {\n            statement.setString(1, longName);\n            try (ResultSet rs = statement.executeQuery()) {\n                if (rs != null) {\n                    int id = rs.getInt(\"ID\");\n                    boolean isActive = rs.getBoolean(\"IsActive\");\n                    String shortName = rs.getString(\"ShortName\");\n\n                    BusLine busLine = new BusLine(id, isActive, longName, shortName);\n                    return Optional.of(busLine);\n                } else {\n                    return Optional.empty();\n                }\n            }\n        } catch (SQLException e) {\n            throw new SQLException(\"Error reading from Stops table: \" + e.getMessage());\n        }\n        //TODO: implement\n//        return Optional.empty();\n    }\n\n    /**\n     * Get BusLine by its full short name (case-insensitive). Return Optional.empty() if no busLine is found.\n     */\n    public Optional<BusLine> getBusLineByShortName(String shortName) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        String sql = \"SELECT * FROM BusLine WHERE ShortName = ?\";\n\n        try (PreparedStatement statement = connection.prepareStatement(sql)) {\n            statement.setString(1, shortName);\n            try (ResultSet rs = statement.executeQuery()) {\n                if (rs != null) {\n                    int id = rs.getInt(\"ID\");\n                    boolean isActive = rs.getBoolean(\"IsActive\");\n                    String longName = rs.getString(\"LongName\");\n\n                    BusLine busLine = new BusLine(id, isActive, longName, shortName);\n                    return Optional.of(busLine);\n                } else {\n                    return Optional.empty();\n                }\n            }\n        } catch (SQLException e) {\n            throw new SQLException(\"Error reading from Stops table: \" + e.getMessage());\n        }\n\n        //TODO: implement\n//        return Optional.empty();\n    }\n\n    /**\n     * Get all BusLines that visit a particular stop\n     */\n    public List<BusLine> getBusLinesByStop(Stop stop) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        List<BusLine> collection = new ArrayList<>();\n\n        String sql = \"SELECT DISTINCT bl.ID, bl.IsActive, bl.LongName, bl.ShortName \" +\n                \"FROM BusLines bl \" +\n                \"JOIN Routes r ON bl.ID = r.BusLineID \" +\n                \"WHERE r.StopID = ? \" +\n                \"ORDER BY bl.ID;\";\n\n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setInt(1, stop.getId());\n\n            try (ResultSet rs = pstmt.executeQuery()) {\n                while (rs.next()) {\n                    int id = rs.getInt(\"ID\");\n                    boolean isActive = rs.getBoolean(\"IsActive\");\n                    String longName = rs.getString(\"LongName\");\n                    String shortName = rs.getString(\"ShortName\");\n                    collection.add(new BusLine(id, isActive, longName, shortName));\n                }\n            }\n        }\n\n        catch (SQLException e) {\n            throw new SQLException(\"Error get bus lines by stop: \" + e.getMessage());\n        }\n        return collection;\n        //TODO: implement\n//        return null;\n    }\n\n    /**\n     * Returns a BusLine's route as a List of stops *in-order*\n     * @param busLine\n     * @throws SQLException\n     * @throws java.util.NoSuchElementException if busLine is not in the database\n     */\n    public Route getRouteForBusLine(BusLine busLine) throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        List<Stop> stops = new ArrayList<>();\n        String sql = \"SELECT s.ID, s.StopName, s.Latitude, s.Longitude \" +\n                \"FROM Routes r \" +\n                \"JOIN Stops s ON r.StopID = s.ID \" +\n                \"WHERE r.BusLineID = ? \" +\n                \"ORDER BY r.RouteOrder;\";\n\n        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {\n            pstmt.setInt(1, busLine.getId());\n\n            try (ResultSet rs = pstmt.executeQuery()) {\n                while (rs.next()) {\n                    int id = rs.getInt(\"ID\");\n                    String name = rs.getString(\"StopName\");\n                    double latitude = rs.getDouble(\"Latitude\");\n                    double longitude = rs.getDouble(\"Longitude\");\n                    stops.add(new Stop(id, name, latitude, longitude));\n                }\n            }\n            return new Route(stops);\n        }\n        catch (SQLException e) {\n            throw new SQLException(\"Error get route for BusLine: \" + e.getMessage());\n        }\n        //TODO: implement\n//        return null;\n    }\n\n    /**\n     * Removes all data from the tables, leaving the tables empty (but still existing!). As a hint, delete the\n     * contents of Routes first in order to avoid violating foreign key constraints.\n     */\n    public void clearTables() throws SQLException {\n        if (connection.isClosed()) {\n            throw new IllegalStateException(\"Connection is closed right now.\");\n        }\n\n        String deleteRoutes = \"DELETE FROM Routes;\";\n        String deleteStops = \"DELETE FROM Stops;\";\n        String deleteBusLines = \"DELETE FROM BusLines;\";\n\n        try (Statement stmt = connection.createStatement()) {\n            stmt.execute(deleteRoutes);\n            stmt.execute(deleteStops);\n            stmt.execute(deleteBusLines);\n\n        } catch (SQLException e) {\n            connection.rollback();\n            throw new SQLException(\"Error clearing tables: \" + e.getMessage());\n        }\n\n        //        try {\n//            //Your JDBC code codes here\n//        } catch (SQLException e) {\n//            rollback(); //rolls back any changes before the Exception was thrown\n//            throw e; //still throws the SQLException\n//        }\n        //TODO: implement\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/edu/virginia/sde/hw5/DatabaseDriver.java b/src/main/java/edu/virginia/sde/hw5/DatabaseDriver.java
--- a/src/main/java/edu/virginia/sde/hw5/DatabaseDriver.java	(revision 5f400d29d16544a7ebee060a524185e1c2b3b4d8)
+++ b/src/main/java/edu/virginia/sde/hw5/DatabaseDriver.java	(date 1713303957971)
@@ -92,7 +92,6 @@
                         "FOREIGN KEY (BusLineID) REFERENCES BusLines(ID) ON DELETE CASCADE, " +
                         "FOREIGN KEY (StopID) REFERENCES Stops(ID) ON DELETE CASCADE);";
 
-        // Using try-with-resources to ensure the statement is closed after execution
         try (Statement statement = connection.createStatement()) {
             statement.execute(Stops);
             statement.execute(BusLines);
Index: src/main/java/edu/virginia/sde/hw5/Configuration.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.virginia.sde.hw5;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.util.Objects;\nimport org.json.JSONObject;\nimport org.json.JSONTokener;\nimport java.util.stream.Collectors;\n\npublic class Configuration {\n    public static final String configurationFilename = \"config.json\";\n\n    private URL busStopsURL;\n\n    private URL busLinesURL;\n\n    private String databaseFilename;\n\n    public Configuration() { }\n\n    public URL getBusStopsURL() {\n        if (busStopsURL == null) {\n            parseJsonConfigFile();\n        }\n        return busStopsURL;\n    }\n\n    public URL getBusLinesURL() {\n        if (busLinesURL == null) {\n            parseJsonConfigFile();\n        }\n        return busLinesURL;\n    }\n\n    public String getDatabaseFilename() {\n        if (databaseFilename == null) {\n            parseJsonConfigFile();\n        }\n        return databaseFilename;\n    }\n\n    /**\n     * Parse the JSON file config.json to set all three of the fields:\n     *  busStopsURL, busLinesURL, databaseFilename\n     */\n    private void parseJsonConfigFile() {\n        try (InputStream inputStream = Objects.requireNonNull(Configuration.class.getResourceAsStream(configurationFilename));\n             BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream))) {\n            String jsonString = bufferedReader.lines().collect(Collectors.joining());\n\n            JSONObject json = new JSONObject(new JSONTokener(jsonString));\n\n            JSONObject endpoints = json.getJSONObject(\"endpoints\");\n            busStopsURL = new URL(endpoints.getString(\"stops\"));\n            busLinesURL = new URL(endpoints.getString(\"lines\"));\n            databaseFilename = json.getString(\"database\");\n//            System.out.println(busStopsURL);\n            //TODO: Parse config.json to set the three fields\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n//\n//    public static void main(String[] args){\n////        Configuration con = new Configuration();\n////        con.parseJsonConfigFile();\n//        try {\n//            Configuration con = new Configuration();\n//            System.out.println(\"Bus Stops URL: \" + con.getBusStopsURL());\n//            System.out.println(\"Bus Lines URL: \" + con.getBusLinesURL());\n//            System.out.println(\"Database Filename: \" + con.getDatabaseFilename());\n//        } catch (Exception e) {\n//            e.printStackTrace(); // This will print the stack trace if any exceptions are caught.\n//        }\n//    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/edu/virginia/sde/hw5/Configuration.java b/src/main/java/edu/virginia/sde/hw5/Configuration.java
--- a/src/main/java/edu/virginia/sde/hw5/Configuration.java	(revision 5f400d29d16544a7ebee060a524185e1c2b3b4d8)
+++ b/src/main/java/edu/virginia/sde/hw5/Configuration.java	(date 1713303871880)
@@ -57,13 +57,12 @@
             busStopsURL = new URL(endpoints.getString("stops"));
             busLinesURL = new URL(endpoints.getString("lines"));
             databaseFilename = json.getString("database");
-//            System.out.println(busStopsURL);
-            //TODO: Parse config.json to set the three fields
+
         } catch (IOException e) {
             throw new RuntimeException(e);
         }
     }
-//
+
 //    public static void main(String[] args){
 ////        Configuration con = new Configuration();
 ////        con.parseJsonConfigFile();
